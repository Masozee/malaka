-- +goose Up
-- Create work orders tables
CREATE TABLE work_orders (
    id SERIAL PRIMARY KEY,
    work_order_number VARCHAR(50) UNIQUE NOT NULL,
    type VARCHAR(20) NOT NULL CHECK (type IN ('production', 'assembly', 'packaging', 'repair', 'maintenance')),
    product_id VARCHAR(50) NOT NULL,
    product_code VARCHAR(50) NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    planned_start_date DATE NOT NULL,
    planned_end_date DATE NOT NULL,
    actual_start_date DATE,
    actual_end_date DATE,
    status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'in_progress', 'paused', 'completed', 'cancelled')),
    priority VARCHAR(10) NOT NULL DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high', 'urgent')),
    warehouse_id INTEGER NOT NULL,
    supervisor VARCHAR(50),
    total_cost DECIMAL(15,2) NOT NULL DEFAULT 0,
    actual_cost DECIMAL(15,2) NOT NULL DEFAULT 0,
    efficiency DECIMAL(5,2) DEFAULT 0 CHECK (efficiency >= 0 AND efficiency <= 100),
    quality_score DECIMAL(5,2) DEFAULT 0 CHECK (quality_score >= 0 AND quality_score <= 100),
    notes TEXT,
    created_by VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (warehouse_id) REFERENCES warehouses(id) ON DELETE RESTRICT
);

-- Create work order materials table
CREATE TABLE work_order_materials (
    id SERIAL PRIMARY KEY,
    work_order_id INTEGER NOT NULL,
    article_id VARCHAR(50) NOT NULL,
    article_code VARCHAR(50) NOT NULL,
    article_name VARCHAR(255) NOT NULL,
    required_quantity INTEGER NOT NULL CHECK (required_quantity > 0),
    allocated_quantity INTEGER NOT NULL DEFAULT 0,
    consumed_quantity INTEGER NOT NULL DEFAULT 0,
    unit_cost DECIMAL(12,2) NOT NULL,
    total_cost DECIMAL(15,2) NOT NULL,
    waste_quantity INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (work_order_id) REFERENCES work_orders(id) ON DELETE CASCADE
);

-- Create work order operations table
CREATE TABLE work_order_operations (
    id SERIAL PRIMARY KEY,
    work_order_id INTEGER NOT NULL,
    operation_number INTEGER NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    planned_duration INTEGER NOT NULL CHECK (planned_duration > 0), -- in hours
    actual_duration INTEGER DEFAULT 0,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped')),
    assigned_to VARCHAR(50),
    machine_id VARCHAR(50),
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (work_order_id) REFERENCES work_orders(id) ON DELETE CASCADE,
    UNIQUE(work_order_id, operation_number)
);

-- Create work order assignments table (many-to-many for assigned employees)
CREATE TABLE work_order_assignments (
    id SERIAL PRIMARY KEY,
    work_order_id INTEGER NOT NULL,
    employee_id VARCHAR(50) NOT NULL,
    role VARCHAR(50) DEFAULT 'worker',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (work_order_id) REFERENCES work_orders(id) ON DELETE CASCADE,
    UNIQUE(work_order_id, employee_id)
);

-- Create indexes for better performance
CREATE INDEX idx_work_orders_number ON work_orders(work_order_number);
CREATE INDEX idx_work_orders_status ON work_orders(status);
CREATE INDEX idx_work_orders_type ON work_orders(type);
CREATE INDEX idx_work_orders_priority ON work_orders(priority);
CREATE INDEX idx_work_orders_warehouse ON work_orders(warehouse_id);
CREATE INDEX idx_work_orders_dates ON work_orders(planned_start_date, planned_end_date);
CREATE INDEX idx_work_orders_created_at ON work_orders(created_at);

CREATE INDEX idx_work_order_materials_work_order ON work_order_materials(work_order_id);
CREATE INDEX idx_work_order_materials_article ON work_order_materials(article_id);

CREATE INDEX idx_work_order_operations_work_order ON work_order_operations(work_order_id);
CREATE INDEX idx_work_order_operations_status ON work_order_operations(status);
CREATE INDEX idx_work_order_operations_assigned_to ON work_order_operations(assigned_to);

CREATE INDEX idx_work_order_assignments_work_order ON work_order_assignments(work_order_id);
CREATE INDEX idx_work_order_assignments_employee ON work_order_assignments(employee_id);

-- Add trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_work_orders_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER trigger_work_orders_updated_at
    BEFORE UPDATE ON work_orders
    FOR EACH ROW
    EXECUTE FUNCTION update_work_orders_updated_at();

CREATE TRIGGER trigger_work_order_materials_updated_at
    BEFORE UPDATE ON work_order_materials
    FOR EACH ROW
    EXECUTE FUNCTION update_work_orders_updated_at();

CREATE TRIGGER trigger_work_order_operations_updated_at
    BEFORE UPDATE ON work_order_operations
    FOR EACH ROW
    EXECUTE FUNCTION update_work_orders_updated_at();

-- +goose Down
DROP TRIGGER IF EXISTS trigger_work_order_operations_updated_at ON work_order_operations;
DROP TRIGGER IF EXISTS trigger_work_order_materials_updated_at ON work_order_materials;
DROP TRIGGER IF EXISTS trigger_work_orders_updated_at ON work_orders;
DROP FUNCTION IF EXISTS update_work_orders_updated_at();
DROP TABLE IF EXISTS work_order_operations;
DROP TABLE IF EXISTS work_order_materials;
DROP TABLE IF EXISTS work_orders;